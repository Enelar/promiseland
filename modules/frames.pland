<{__promiseLandModule: true}>;

/* 
  frame system
  registration of frames
  inter communication between frames
  frame base classes
*/


var classSystem;
var internalObjects;
((){
  classSystem = (*extra.classSystemPs).classSystem;
  internalObjects = (*extra.classSystemPs).internalObjects;
})();

var config = extra.config;



    var moduleData = {};

    var profiles = {};
    
    var _emitFun = function(parEventStr, parData){
        if (this._on[parEventStr]){
          var i = 0;
          var l = this._on[parEventStr].length;
          for (i; i < l; ++i){
            try{
              this._on[parEventStr][i](parData);
            }catch(e){};
          };
        };
      };
    var _onFun = function(parEventStr, parFun){
        if (this._on[parEventStr]){
          this._on[parEventStr].push(parFun);
        };
      };
    
    // base classes
    var Profile = function(){
      this._on = {
        "connection": []
      };
    };
    Profile.prototype = {
      // return the name of the profile
      name: function(){
        
      },
      
      emit: _emitFun,
      
      // return Connection object
      find: function(parId /*optional*/){
        
      },
      
      // return array of provided Profiles
      /*providesProfiles: function(){
        
      },*/
      
      /* events:
        "connection":   a new connection was initiated - function(parConnection){}
      */
      on: _onFun
    };
    
    var Connection = function(){
      this._on = {
        "data": [],
        "disconnect": []
      };
    };
    Connection.prototype = {
      /* send string to counterpart object on the other frame */
      send: function(parStr){
        
      },
      
      emit: _emitFun,
      
      /* events:
        "data":        data arrives - function(parDataStr){}
        "disconnect":  connection got permanently disconnected
      */
      on: _onFun
    };
    
    
    var remoteExecRequest = function(connection, par){
      console.log("remote");
      try{
      var data = par.data;
      
      var moduleData = getModuleData(data.hashStr);
      
      
      var funEntry = moduleData.functions[data.nameStr];
      //console.log(funEntry);
      
      if (promiseland.profileHas(funEntry.profile)){
        
        var funType = funEntry.funType;
        var resultType = classSystem.getFunctionReturnType(funType);
        var isVar = true;
        if (!classSystem.isVar(resultType)){
          isVar = false;
        };
        var resultPs = new Promise();
        
        // to be reused for all reject cases
        var tempRejectFun = function(reason){
          resultPs.reject(reason);
        };
        
        var funResult = funEntry.fun.apply(undefined, data.args);
        
        // var case
        if (isVar){
          console.log("isvar true");
          funResult.then(function(parResult){
            resultPs.resolve({
              isVar: true,
              data: parResult
            });
          }, tempRejectFun);
          return resultPs;
        };
        
        // typed case
        
        if (!classSystem.isTemporaryTrackedClass(resultType)){
          console.log("not temp checked");
          // result must be a temporary tracked promise
          resultPs.reject(errorMsg.notASyncableResponse);
          return;
        };
        

        var promiseResult = funResult[0];
        var promiseResultTrack = funResult[1];
        
        var promiseType = classSystem.getClassFromTemporaryTracked(resultType);
        if (!classSystem.isPromiseOfClass(promiseType)){
          // result must be a promsie
          console.log("not promise");
          resultPs.reject(errorMsg.notASyncableResponse);
          promiseResultTrack(); // untrack result
          return;
        };
        
        console.log("waiting for result");
        console.log(promiseResult);
        promiseResult.then(function(parResult){
          console.log("we got a result");
          
          // we dont need the promise itself any longer
          promiseResultTrack(); // untrack promise itself
          
          // parResult is by definition a temporary tracked
          var realResult = parResult[0];
          var trackResult = parResult[1];
          
          if (!realResult){
            // emptyresult
            trackResult();
            resultPs.resolve();
            return;
          };
          
          // sync object
          var internalId = classSystem.getInternalId(realResult);
          if (connection.hasObject(internalId)){
            resultPs.resolve({ // just send the id - the other frame knows what to do
              id: connection.getTransferId(internalId)
            });
            trackResult(); // untrack
            return;
          };
          
          console.log("generating syncRequestData");
          var syncRequestData = classSystem.getSyncRequestData(realResult, connection);
          console.log(syncRequestData);
          resultPs.resolve(syncRequestData);
          trackResult(); // untrack // getSyncRequestData must make its own track entry
          
        }, function(reason){
          console.log("we got a rejection");
          console.log(reason);
          resultPs.reject(reason);
          promiseResultTrack(); // untrack promise itself
        });

        return resultPs;
      };
      }catch(e){
        console.log("error");
        console.log(e);
        var rejectPs = new Promise();
        rejectPs.reject(e);
        return rejectPs;
        
      };

      var rejectPs = new Promise();
      rejectPs.reject(errorMsg.frameNotAvailable);
      return rejectPs;
    };
    
    var maxId = 10000000;
    
    var prepConnection = function(connection, profile){
      var buffer = {};
      var expectid = 1;
      var nextId = 1;
      var requests = {};
      
      var profilenameStr = "" + profile.name();
      
      var sendData = function(data){
        var id = nextId;
        nextId++;
        if (nextId > maxId){
          nextId = 1;
        };
        data.id = id;
        connection.send(JSON.stringify(data));
        return id;
      };
      
      var internalObjectMap = {};
      var transferIdMap = {};
      var nextTranseferId = 1;
      
      connection.hasObject = function(parId){
        if (!internalObjects[parId]){
          return false;
        };
        if (internalObjectMap[parId]){
          return true;
        };
        return false;
      };
      connection.getTransferId = function(parId){
        return internalObjectMap[parId].transferId;
      };
      connection.newTransferId = function(parId, parTrack, transferId){
        if (internalObjectMap[parId]){
          if (parTrack){
            parTrack();
          };
          return internalObjectMap[parId].transferId;
        };
        var syncData = classSystem.getSyncData(internalObjects[parId]);
        syncData.connections.push(connection);
        
        if (!transferId){
          transferId = profilenameStr + (nextTranseferId++);
        };
        var entry = {
          transferId: transferId,
          internalId: parId,
          track: parTrack
        };
        internalObjectMap[parId] = entry;
        transferIdMap[entry.transferId] = entry;
        return entry.transferId;
      };
      connection.removeSynced = function(parId){
        if (!internalObjectMap[parId]){
          return;
        };
        var entry = internalObjectMap[parId];
        var transferId = entry.transferId;
        internalObjectMap[entry.internalId] = undefined;
        transferIdMap[entry.transferId] = undefined;
        if (entry.track){
          entry.track();
        };
        connection.createMsg({
          type: "unsync",
          transferId: transferId
        });
        // remove connection from syncdata
        var syncData = classSystem.getSyncData(internalObjectMap[parId]);
        var i = 0;
        var newConAr = [];
        for (i = 0; i < syncData.connections.length; ++i){
          var c = syncData.connections[i];
          if (c !== connection){
            newConAr.push(c);
          };
        };
        syncData.connections = newConAr;
      };
      connection.unsync = function(parTransferId){
        var entry = transferIdMap[parTransferId];
        internalObjectMap[entry.internalId] = undefined;
        transferIdMap[entry.transferId] = undefined;
        if (entry.track){
          entry.track();
        };
      };
      
      connection.syncValue = function(par){
        /*{
            transferId: connection.getTransferId(syncData.getInternalId()),
            memberIdx: memberIdx,
            value: value
          });*/
        connection.createMsg({
          type: "syncValue",
          transferId: par.transferId,
          memberIdx: par.memberIdx,
          value: par.value
        });
        
      };
      
      connection.recieveSyncValue = function(par){
        var entry = transferIdMap[par.transferId];
        var instance = internalObjects[entry.internalId];
        if (!instance){
          return;
        };
        instance[par.memberIdx] = par.value;
      };
      
      
      var rejectFun = function(parId){
        return function(parReason){
          sendData({
            response: parId
            , reject: true
            , data: parReason
          });
        };
      };
      var resolveFun = function(parId){
        return function(parResult){
          sendData({
            response: parId
            , resolve: true
            , data: parResult
          });
        };
      };
      var respondError = function(parId, parError){
        return (rejectFun(parId))(parError);
      };
      
      var queue = function(par){
        if (par.id == expectid){
          ++expectid;
          if (expectid > maxId){
            expectid = 1;
          };
          if (par.request){
            if (par.data && par.data.type == "remoteexec"){
              var p = remoteExecRequest(connection, par);
              p.then(resolveFun(par.id), rejectFun(par.id));
            }else{
              respondError(par.id, {
                msg: "unknownRequest"
              });
            };
          }else if (par.msg){
            if (par.data && par.data.type == "unsync"){
              connection.unsync(par.data.transferId);
            };
            if (par.data && par.data.type == "syncValue"){
              connection.recieveSyncValue(par.data);
            };
            
          }else if (par.response !== undefined){
            var ps = requests[par.response];
            if (ps){
              delete requests[par.response];
              if (par.resolve){
                ps.resolve(par.data);
              }else{
                ps.reject(par.data);
              };
            };
          };
        }else{
          buffer[par.id] = par;
        };
        var b = buffer[expectid];
        if (b){
          delete buffer[expectid];
          queue(b);
        };
      };
      
      connection.on("data", function(dataStr){
        var obj = JSON.parse(dataStr);
        queue(obj);
      });
      
      connection.on("disconnect", function(dataStr){
        var e;
        for (e in internalObjectMap){
          var entry = internalObjectMap[e];
          if (entry.track){
            entry.track();
          };
        };
        internalObjectMap = {};
        transferIdMap = {};
      });
      
      connection.createRequest = function(data){
        var ps = new Promise();
        var id = sendData({
          request: true
          , data: data
        });
        requests[id] = ps;
        return ps.promise;
      };
      
      connection.createMsg = function(data){
        var id = sendData({
          msg: true
          , data: data
        });
        return;
      };
      
    };
    
    /*
      par: {
          conection: connection,
          hashStr: hashStr,
          nameStr: nameStr,
          args: args,
          promise: promise
        }
    */
    var createRemoteExecRequest = function(par){
      var connection = par.connection;
      var args = [];
      if (par.args && par.args.length){
        var i = 0;
        for (i = 0; i < par.args.length; ++i){
          args.push(par.args[i]);
        };
      };

      var funType = par.funType;

      var resultType = classSystem.getFunctionReturnType(funType);
      var isVar = true;
      if (!classSystem.isVar(resultType)){
        isVar = false;
      };

      var ps = connection.createRequest({
        "type": "remoteexec",
        hashStr: par.hashStr,
        nameStr: par.nameStr,
        args: args
      });

      ps.then(function(res){
        if (isVar && res.isVar){
          par.promise.resolve(res.data);
        };
        if (isVar || res.isVar){
          par.promise.reject(errorMsg.typeMissmatch);
          // needs check for tracking
        };

        // typed case
        if (!classSystem.isTemporaryTrackedClass(resultType)){
          // result must be a temporary tracked promise
          par.promise.reject(errorMsg.notASyncableResponse);
          return;
        };
        var promiseType = classSystem.getClassFromTemporaryTracked(resultType);
        if (!classSystem.isPromiseOfClass(promiseType)){
          // result must be a promsie
          par.promise.reject(errorMsg.notASyncableResponse);
          return;
        };
        
        // empty result
        if (!res){
          par.promise.resolve();
          return;
        };
        
        // we should have this obj already
        if (res.id){
          connection.getObjectByTransferId(res.id).then(function(parObj){
            par.promise.resolve(parObj);
          }, function(reason){
            par.promise.reject(reason);
          });
          return;
        };
        
        // a new obj to track
        var obj = classSystem.getObjFromSyncData(res, connection);
        par.promise.resolve(obj);
        if (obj){
          obj[1]();
        };

      }, function(res){
        par.promise.reject(res);
      });
    };


    var findProfile = function(profileNameStr){
      return profiles[profileNameStr];
    };

    var getModuleData = function(parHash){
      if (!moduleData[parHash]){
        moduleData[parHash] = {
          functions: {},
          classes: {}
        };
      };
      return moduleData[parHash];
    };


promiseland.ProfileBaseClass = Profile;
promiseland.ConnectionBaseClass = Connection;


promiseland.addProfile = function(parProfile){
        if (!parProfile){
          return;
        };
        if (profiles[parProfile.name()]){
          throw {
            code: 4,
            msg: "profile exists"
          };
        };
        profiles[parProfile.name()] = parProfile;
        parProfile.on("connection", function(connection){
          prepConnection(connection, parProfile);
        });
      };
promiseland.profileHas = function(profileNameStr){
        if (config.profile === profileNameStr){
          return true;
        };
        return false;
      };


promiseland.registerRemote = function(profileNameStr, hashStr, nameStr, fun, funType){
        var moduleData = getModuleData(hashStr);
        var entry = {
          profile: profileNameStr,
          fun: fun,
          funType: funType
        };
        moduleData.functions[nameStr] = entry;
        classSystem.definitionPromise(funType).then(function(definedFunType){
          entry.funType = definedFunType;
        });
      };

promiseland.remoteExec = function(hashStr, nameStr, args, parPromise){
        var promise = parPromise;
        var ret = promise.promise;
        var moduleData = getModuleData(hashStr);
        if (!moduleData || !moduleData.functions[nameStr]){
          promise.reject(errorMsg.missingRemoteFun);
          return ret;
        };
        var entry = moduleData.functions[nameStr];
        var profile = findProfile(entry.profile);
        if (!profile){
          promise.reject(errorMsg.frameNotFound);
          return ret;
        };
        
        var connection = profile.find();
        if (!connection){
          promise.reject({
            code: 3
            , msg: "no connection available"
          });
          return ret;
        };
        
        createRemoteExecRequest({
          connection: connection,
          hashStr: hashStr,
          nameStr: nameStr,
          args: args,
          promise: promise,
          funType: entry.funType
        });
        
        return promise.promise;
      };

extra.moduleSystemPs.resolve({
  getModuleData: getModuleData
});


    var errorMsg = {
      
      missingRemoteFun: {
        id: 801
        , msg: "remote function not registred"
      },
      frameNotAvailable: {
        id: 802,
        msg: "requested frame not available"
      },
      frameNotFound: {
        id: 803,
        msg: "requested frame not found"
      }
    };



return;
