
var md5 = require "./md5";
var _parser = require "./_parser";

var basics = require "./basics";
var errorFun = basics.errorFun;
var errorMsg = basics.errorMsg;
var _stringEncodeStr = basics._stringEncodeStr;
var stringEncodeStr = basics.stringEncodeStr;

var VariableNames = basics.VariableNames;
var mixin = basics.mixin;
var identifierName = basics.identifierName;
var checkIsFunction = basics.checkIsFunction;

var getExtraFromPar = basics.getExtraFromPar;
var addExtraToPar = basics.addExtraToPar;
var statementType = basics.statementType;
var checkPromising = basics.checkPromising;

var loaderStr = require "./loader";


var parseFunctionModule = require "./parseFunction";
var variablesModule = require "./variables";
var typesModule = require "./types";
var expressionsModule = require "./expressions";
var dynamicModule = require "./dynamic";

var asmModule = require "./asm";


/* debugging flags
*/

var _pureCode = false;

var Promise = promiseland.Promise;

var classSystem = promiseland.classSystem;

/*var statementType = {
  builtin: true
  , statement: true
};*/
var varType = classSystem.getBuiltinType("var");


var globalNewPromiseStr = function(){
  return "new __Promise()";
};


var Map = promiseland.Map;

    
/* pre processors */

var findPromises = function(par){
  if (!par || typeof par == "string"){
    return false;
  };
  if (par.type == "UnaryExpression" && (par.operator == "*" || par.operator == "require")){
    par.promising = true;
  };
  if (checkIsFunction(par) && par.promise == "*"){
    par.promising = true;
  };
  var i;
  for (i in par){
    if (i == "_extrainfo"){
      continue;
    };
    if (findPromises(par[i]) && !checkIsFunction(par[i])){
      par.promising = true;
    };
  };
  if (par.promising){
    return true;
  };
  return false;
};
    
    
    
    
var _Result = require "./Result";
    
    
    /* internal parser object */
    
    var CodeParser = function(par){
      var self = this;
      this.toParse = par.toParse;
      this.dynamicCode = par.dynamicCode;
      this.hashStr = par.hashStr;
      
      this.asmMode = par.asmMode || false;
      
      // initialization
      if (par._locals){
        for (var i in par._locals){
          this[i] = par._locals[i];
        };
      };
      
      if (par.common){
        this.common = par.common;
      }else{
        this.common = {
          givenTypeNames: {},
          errors: [],
          uniquebasis: par.uniquebasis || {
            index: 1
          },
          parsingConfig: par.parsingConfig
        };
        this.common.variableNames = new VariableNames({
          getUniqueName: (name){
            return self.getUniqueName(name);
          }
        });
      };
      
      this.errors = this.common.errors;
      
      this.newPromiseStr = function(){
        this.common.usePromise = true;
        return globalNewPromiseStr();
      };
      
      
      typesModule(this, par);
      
      /* flags */
      
      this.algorithmicCode = false;
      
      /* used to stack / unstack flags */
      
      this.stack = function(parStr){
        var stackNameStr = "_stack_" + parStr;
        if (!this[stackNameStr]){
          this[stackNameStr] = [];
        };
        this[stackNameStr].push(this[parStr]);
      };
      this.unstack = function(parStr){
        var stackNameStr = "_stack_" + parStr;
        this[parStr] = this[stackNameStr].pop();
      };
      
      
      /* main function */
      
      this._start = function(){
        if (this.toParse){
          if (this.toParse.type == "Program"){
            var tempRes = this.makeCompleteStatement(this.parseProgram(this.toParse));
            tempRes.push(";");
            this.result = this.makeCompleteStatement(tempRes);
          }else if (checkIsFunction(this.toParse)){
            this.functionRes = this.parseFunction(this.toParse);
            this.result = this.makeCompleteStatement(this.functionRes);
          };
        };
      };
      
      
      this.makeCompleteStatement = function(par){
        var res = this.newResult();
        res.setComplete();
        res.push(par);
        return res;
        
      };
      
      
        
      variablesModule(this, par);
      
        
      
      
      
      
      
      
      this._getErrors = function(parWarning){
        var a = [];
        var i = 0;
        for (i = 0; i < this.errors.length; ++i){
          if (this.errors[i].valid){
            if (this.errors[i].dbgFun){
              try{
                this.errors[i].dbgFun();
              };
            };
            if (parWarning ? this.errors[i].warning : !this.errors[i].warning){
              a.push(this.errors[i]);
            };
          };
        };
        return a;
      };
      
      this.getWarnings = function(){
        return this._getErrors(true);
      };
      this.getErrors = function(){
        return this._getErrors(false);
      };
      
      this.getWarningFun = function(par){
        var self = this;
        return function(err){
          self.warning(par, err);
        };
      };
      
      this.warning = function(par, err){
        if (!par.line){
          errorFun({}, errorMsg.internalParserInfoMissing);
        };
        this.addWarning(par, err);
      };
      
      this.error = function(par, err){
        this._addError(par, err);
        errorFun(par, err);
      };
      this.addError = function(par, err, dbgFun){
        return this._addError(par, err, false, dbgFun);
      };
      this.addWarning = function(par, err){
        return this._addError(par, err, true);
      };
      this._addError = function(par, err, warning, dbgFun){
        var entry = {
          par: par,
          line: par.line,
          column: par.column,
          msg: err.id + ": " + err.msg,
          valid: true,
          warning: warning,
          dbgFun: dbgFun
        };
        this.errors.push(entry);
        var ps = new Promise();
        ps.then(function(){
          entry.valid = false;
        });
        return ps;
      };
      
      /*
        you can pass a optional promise.
        when the promise gets resolved, the result is replaced with the resolved value
        and the warning gets removed
      */
      this.runtimeError = function(par/*parsed entry*/, par2/*error msg*/){
        var ps = this.addWarning(par, par2);
        
        var res = this.runtimeErrorNoWarning(par2);
        res.setPromise(ps);
        //this.getWarningFun(par)(par2);
        return res;
      };
      
      this.runtimeErrorNoWarning = function(par2){
        var res = this.newResult();
        res.push("(function(){ throw { id:" + par2.id + ", msg: " + stringEncodeStr(par2.msg) + " } })()");
        return res;
      };
      
      
      this.getUniqueName = function(name){
        var retStr = "PL$" + this.common.uniquebasis.index++;
        if (name){
          retStr += "/*" + name + "*/";
        };
        return retStr;
      };
      
      
      
      
      // make a new instance of parser for subfunctions etc.
      
      this.newInstance = function(element, extras){
        var param = {
          toParse: element
          , common: this.common
          , hashStr: this.hashStr
          , types: this.types
          , variables: this.variables
          , _locals: {
            inheritedSystem: this.inheritedSystem,
            isClassObject: this.isClassObject
          }
        };
        if (extras){
          var i;
          for (i in extras){
            param[i] = extras[i];
          };
        };
        var instance = new CodeParser(param);
        return instance;
      };
      
      
      /* results */
      
      this.getFunctionRes = function(){
        return this.functionRes;
      };
      
      this.getFunctionName = function(){
        return this.functionName;
      };
      
      
      this.getResult = function(){
        return this.result;
      };
      
      
      this.result = "";
      
      
      this.newResult = function(par){
        var r = new _Result({
          cp: this
        });
        if (par){
          r.push(par);
        };
        return r;
      };
      
      
      
      
      /*
        complete program
      */
      this.parseProgram = function(par){
        findPromises(par);
        var res = this.newResult();
        
        var extraRes = this.newResult();
        extraRes.push("\"use strict\";\n");
        addExtraToPar(par, "addFront", extraRes);
        
        
        var extraModules = new Map();
        var parsingConfig = this.common.parsingConfig;

        if (parsingConfig){
          var reqireProperty = this.getTemplateProperty(parsingConfig, "require", "ObjectExpression");
          if (reqireProperty){
            extraModules = this.getTemplateRequireProperty(reqireProperty);
          };
          var nameProperty = this.getTemplateProperty(parsingConfig, "name", "Literal");
          if (nameProperty){
            this.common.name = nameProperty;
          };
        };
        this.common.extraModules = extraModules;
        
        
        if (checkPromising(par)){
          this.programPromiseStr = this.getUniqueName();
        };
        
        this.resultNameStr = this.getUniqueName();
        
        var functionStatement = this._parseFunction(par, { promiseName: this.programPromiseStr, noUntrack: true });
        
        var name;
        this.usedVariablesMap.forEach((value, name){
          if (value === true){
            if (name == "Promise"){
              this.common.usePromise = true;
            };
            if (name == "Callback"){
              this.common.useCallback = true;
            };
            if (name == "Map"){
              this.common.useMap = true;
            };
            if (extraModules.get(name)){
              return;
            };
            res.push("var " + this.getVariableName(name) + ";");
            res.push("try{");
            res.push(this.getVariableName(name));
            res.push(" = ");
            res.push(name);
            res.push(";}catch(e){};\n");
          };
        }, this);
        
        //res.push("var ");
        //res.push(this.renderType("var"));
        //res.push(" = classSystem.getBuiltinType(\"var\");\n");
        //this.common.useClassSystem = true;
        
        res.push("var " + this.resultNameStr + " = (");
        res.push(this.makeCompleteStatement(functionStatement));
        res.push(")();\n");
        
        return res;
      };
      
      
      
      parseFunctionModule(this, par);
      
      
      this.getTemplateProperty = function(parTemplate, parProperty, mandatoryType){
        var i = 0;
        for (i; i < parTemplate.properties.length; ++i){
          var p = parTemplate.properties[i];
          if (p.kind == "init" && identifierName(p.key) == parProperty){
            if (mandatoryType){
              if (p.value.type != mandatoryType){
                this.error(p.value, errorMsg.templateSyntaxError);
              };
            };
            return p.value;
          };
        };
      };
      
      this.getTemplateRequireProperty = function(parTemplate){
        var i = 0;
        var res = new Map();
        for (i; i < parTemplate.properties.length; ++i){
          var p = parTemplate.properties[i];
          if (p.kind == "init"){
            var key = identifierName(p.key);
            if (p.value.type != "Literal"){
              this.error(p.value, errorMsg.templateSyntaxError);
            };
            res.set(key, p.value.value);
          };
        };
        return res;
      };
        
      
      this.createExtraDynamicType = function(parType, par, parParsed){
        var name;
        if (par.property){
          name = this.getTypeName(parType, parParsed) + "::property::" + par.property;
          
        }else if (par.temporaryTracked){
          name = this.getTypeName(parType, parParsed) + "::temporaryTracked";
          
        }else if (par.temporaryTrackedResolved){
          name = this.getTypeName(parType, parParsed) + "::temporaryTrackedResolved";
          
        }else if (par.constructorReturn){
          name = this.getTypeName(parType, parParsed) + "::constructorReturn";
          
        }else{
          this.error(errorMsg.internalMissingTypeProperty);
        };
        
        
        if (!parType.extraTypes){
          parType.extraTypes = [];
        };
        if (!parType.extraTypeMap){
          parType.extraTypeMap = new Map();
        };
        
        
        if (parType.extraTypeMap.has(name)){
          return parType.extraTypeMap.get(name);
        };
        
        var entry = {
          res: this.newResult()
        };
        parType.extraTypes.push(entry);
        var res = entry.res;
        
        this.addType({name: name, dynamic: true}, parParsed);
        
        res.push("var /*extratyperender*/ ");
        res.push(this.renderType(name));
        res.push(" = ");
        
        this.common.useClassSystem = true;
        
        if (par.property){
          if (par.property == "constructor"){
            res.push("classSystem.getConstructorType({\"type\":");
          }else{
            res.push("classSystem.getPropertyType({\"type\":");
          };
          res.push(this.renderType(parType));
          res.push(", property: " + stringEncodeStr(par.property));
          res.push("});\n");
          
        }else if (par.temporaryTracked){
          res.push("classSystem._createTemporaryTrackedClass(");
          res.push(this.renderType(parType));
          res.push(");\n");
          
        }else if (par.temporaryTrackedResolved){
          res.push("classSystem.getClassFromTemporaryTracked(");
          res.push(this.renderType(parType));
          res.push(");\n");
          
        }else if (par.constructorReturn){
          res.push("classSystem.getConstructorReturnType(");
          res.push(this.renderType(parType));
          res.push(");\n");
          
        };
        
        var newType = this.getType(name, parParsed);
        entry.type = newType;
        parType.extraTypeMap.set(name, newType);
        return newType;
        
      };
      
      
      /*
        code to be executed before the function returns
        even when a exception happens
        
        extensive condition tracking is in order since the code generation can depend on dynamic classes
        see createConditionalCode for more clarity
      */
      
      this.addBeforeReturn = function(parRes, parCondition){
        
        var condition = parCondition;
        if (parCondition === undefined){
          condition = true;
        };
        
        var conditional = this.createConditionalCode(parRes);
        conditional.addCondition(condition);
        
        this.runBeforeReturnRes.push(conditional.res);
        
        
        if (!this.beforeReturnExists){
          this.beforeReturnExists = true;
          
          var frontRes = this.newResult();
          var endRes = this.newResult();
          this.beforeReturnFrontConditional = this.createConditionalCode(frontRes);
          this.beforeReturnEndConditional = this.createConditionalCode(endRes);
          
          this.beforeReturnExistsPs.resolve(this.runBeforeReturnRes);
          if (!this.promising){ // promising functions have their own error handler
            // this is to execute the code even if an exception happens
            frontRes.push("try{");
            this.additionalCodeFrontRes.push(this.beforeReturnFrontConditional.res);
            
            endRes.push("}catch(e){");
            endRes.push(this.runBeforeReturnRes);
            endRes.push("throw e};");
            this.additionalCodeEndRes.push(this.beforeReturnEndConditional.res);
            
          };
        };
        
        this.beforeReturnFrontConditional.addCondition(condition);
        this.beforeReturnEndConditional.addCondition(condition);
        
        this.addBeforeReturnCondition(condition);
        
      };
      
      this.beforeReturnConditions = [];
      this.addBeforeReturnCondition = function(parCondition){
        this.beforeReturnConditions.push(parCondition);
        var i = 0;
        for (i = 0; i < this.beforeReturnConditionFuns.length; ++i){
          this.beforeReturnConditionFuns[i](parCondition);
        };
      };
      
      this.beforeReturnConditionFuns = [];
      this.addBeforeReturnConditionFun = function(parFun){
        this.beforeReturnConditionFuns.push(parFun);
        var i = 0;
        for (i = 0; i < this.beforeReturnConditions.length; ++i){
          parFun(this.beforeReturnConditions[i]);
        };
      };
      
      this.getReturnCode = function(par){
        var self = this;
        var res = this.newResult();
        
        if (this.promising){
          res.push(this.returnPromise + ".resolve(");
          if (par.value){
            res.push(par.value);
          };
          res.push("); return");
          
        }else{
          if (par.return || par.value){
            res.push("return");
          };
          if (par.value){
            res.push(" ");
            res.push(par.value);
          };
          if (par.return || par.value){
            //res.push(";");
          };
          
        };
        
        var falseRes = res;
        
        
        var beforeReturnCode = this.runBeforeReturnRes;
        
        var newRes = self.newResult();

        var valueRes = self.newResult();
        if (par.value){
          valueRes.push("(function(ret){ ");
          valueRes.push(beforeReturnCode);
          valueRes.push("return ret; })(");
          valueRes.push(par.value);
          valueRes.push(")");

        };

        if (self.promising){
          if (par.value){
            newRes.push(self.returnPromise + ".resolve(");
            newRes.push(valueRes);
            newRes.push("); return;");

          }else{
            newRes.push(beforeReturnCode);
            newRes.push(self.returnPromise + ".resolve(");
            newRes.push("); return;");

          };

        }else{
          if (par.value){
            newRes.push("return ");
            newRes.push(valueRes);
            newRes.push(";");

          }else{
            newRes.push(beforeReturnCode);
            if (par.return){
              newRes.push("return;");
            };

          };
        };
        
        var trueRes = newRes;
        
        var conditional = this.createConditionalCode(trueRes, falseRes);
        this.addBeforeReturnConditionFun(function(con){
          conditional.addCondition(con);
        });
        
        return conditional.res;
      };


        
      expressionsModule(this, par);
      
      
      
      
      
      
      
      
      
      

      
      
      

      
      
      
      
      
      
      
      this.getModuleHashStr = function(){
        return this.hashStr || "unknownhash";
      };
      
      
      this.makeStatement = function(par){
        var statementRes = this.newResult();
        statementRes.setStatement();
        statementRes.push(par);
        statementRes.push(";");
        return statementRes;
      };
      
      
      
      this.newLine = (){
        var res = this.newResult();
        res._newLine = true;
        return res;
      };
      
      this.indent = (parRes){
        var res = this.newResult();
        res._indent = true;
        if (parRes){
          res.push(parRes);
        };
        return res;
      };
      
      
      
      
      this.newInherited = function(){
        return new InheritedSystem(this);
      };
      
      var InheritedSystem = function(par){
        this.instance = par;
        this.used = {};
      };
      InheritedSystem.prototype = {
        setCurrent: function(par){
          this.currentMember = par;
        },
        getCurrent: function(){
          if (!this.used[this.currentMember]){
            this.used[this.currentMember] = this.instance.getUniqueName("inherited " + this.currentMember);
          };
          return this.used[this.currentMember];
        }
      };
      
      
      
      
      
      
      
      
      
      dynamicModule(this, par);
      
      
      
      
      
      
      /*
        returns {
          res
          addCondition()
        }
      */
      this.createConditionalCode = function(parTrueRes, parFalseRes){
        var self = this;
        parTrueRes = parTrueRes || this.newResult();
        parFalseRes = parFalseRes || this.newResult();
        var isDecided = false;
        var conditions = [];

        var res = this.newResult();
        res.replace(parFalseRes);
        
        return {
          res: res,
          
          addCondition: function(parCondition){
            if (isDecided){
              return;
            };
            if (parCondition === true){
              isDecided = true;
              res.replace(parTrueRes);
              return;
            };
            if (parCondition === false){
              return;
            };
            
            conditions.push(parCondition);
            
            var ifRes = self.newResult();
            ifRes.push("((");
            var i = 0;
            for (i = 0; i < conditions.length; ++i){
              if (i){
                ifRes.push(" && ");
              };
              ifRes.push(conditions[i]);
            };
            ifRes.push(") ? (");
            ifRes.push(self.makeCompleteStatementDynamic(parTrueRes));
            ifRes.push(") : (");
            ifRes.push(self.makeCompleteStatementDynamic(parFalseRes));
            ifRes.push("))");
            
            var dynRes = self.newResult();
            dynRes.push(self.makeCompleteStatement(ifRes), undefined, {
              dynamic: true
            });
            
            res.replace(dynRes);
            
          }
        };
      };

      
      
      
      
      
      
      this.isCallableType = function(){
        
      };
      
      
      
      this.getFunctionArgumentCount = function(parType, parsed){
        return classSystem.getFunctionArgumentCount(parType);
      };
      
      
      asmModule(this, par);
      
      
      this._start();
      
    };
    
    
    var promiselandRequireStr = function(){
      return "";
    };
    var callbackRequireStr = function(){
      return "var Callback = promiseland.Callback;\n";
    };
    var mapRequireStr = function(){
      return "var Map = promiseland.Map;\n";
    };
    
    var loaderEndStr = function(par){
      if (par.promiseLandModule){
        return "}; return function(){ return __execute.apply(null, arguments); } });\n})();";
      }else{
        return "});\n})();";
      };
    };
    
    
    
    
    var createHeader = function(par){
      if (_pureCode){
        return "";
      };
      var resStr = "";
      
      
      var loaderParam = {
        usePromise: par.usePromise,
        useRequire: par.useRequire,
        useClassSystem: par.useClassSystem,
        extraModules: par.extraModules,
        variableNames: par.variableNames,
        hashStr: par.hashStr
      };
      
      if (par.makePromiseLandModule){
        loaderParam.promiseLandModule = true;
      };
      resStr += loaderStr(loaderParam);
      resStr += promiselandRequireStr();
      if (par.useCallback){
        resStr += callbackRequireStr();
      };
      if (par.useMap){
        resStr += mapRequireStr();
      };
      
      resStr += "if (promiseland._hasModule({ hashStr: \"" + par.hashStr + "\" })){ return promiseland._getModule(\"" + par.hashStr + "\"); };\n";
      return resStr;
    };
    
    var createFooter = function(par){
      if (_pureCode){
        return "";
      };
      var resStr = "";
      
      if (par.makePromiseLandModule){
        resStr += loaderEndStr({
          promiseLandModule: true
        });
      }else{
        resStr += loaderEndStr({});
      };
      return resStr;
    };
    
    
    /* 
      the main parser object
    */
    
    var parser = {
      parse: function(promiselandCodeStr){
        var p = new promiseland.Promise();
        var parser = _parser;
        var hashStr = md5(promiselandCodeStr);
        var parsed = parser.parse(promiselandCodeStr);
        var resStr = "";
        var cp;
        var res = {};
        if (parsed.length === undefined){
          if (parsed.type == "Program"){
            var parsingConfig = parsed.config;
            
            cp = new CodeParser({
              toParse: parsed, 
              hashStr: hashStr,
              parsingConfig: parsingConfig
            });
            
            var makePromiseLandModule = false;
            var extraModules = cp.common.extraModules;
            var variableNames = cp.common.variableNames;
            
            if (parsingConfig){
              makePromiseLandModule = cp.getTemplateProperty(parsingConfig, "__promiseLandModule", "Literal");
              if (makePromiseLandModule && makePromiseLandModule.value === true){
                makePromiseLandModule = true;
              }else{
                makePromiseLandModule = false;
              };
            };
            var result = cp.getResult();
            var programStr = result.getProgramCodeStr();
            res.warnings = cp.getWarnings();
            res.errors = cp.getErrors();
            
            
            var mainPartStr = "";
            
            if (_pureCode){
              resStr = programStr;
              
            }else{
              if (cp.programPromiseStr){
                // promising module
                mainPartStr += "var " + cp.programPromiseStr + " = " + cp.newPromiseStr() + ";\n";
                mainPartStr += "promiseland._registerModule({ hashStr: \"" + hashStr + "\", \"module\": " + cp.programPromiseStr + ", promising: true });\n";
                mainPartStr += programStr;
                mainPartStr += ";\nreturn " + cp.programPromiseStr;
              }else{
                mainPartStr += programStr;
                // no need to register non promising modules
                // #requireMagic
                //mainPartStr += "promiseland._registerModule({ hashStr: \"" + hashStr + "\", \"module\": " + cp.resultNameStr + ", promising: false });\n";
                mainPartStr += "return " + cp.resultNameStr + ";\n";
              };

              resStr += createHeader({
                makePromiseLandModule: makePromiseLandModule,
                extraModules: extraModules,
                variableNames: variableNames,
                hashStr: hashStr,
                usePromise: cp.common.usePromise,
                useRequire: cp.common.useRequire,
                useCallback: cp.common.useCallback,
                useMap: cp.common.useMap,
                useClassSystem: cp.common.useClassSystem
              });

              resStr += mainPartStr;

              resStr += createFooter({
                makePromiseLandModule: makePromiseLandModule
              });
              
            };
          }else{
            this.error(parsed, errorMsg.unknownType);
          };

        }else{
          errorFun(parsed, errorMsg.severalProgramElements);
        };
        if (!(res.errors && res.errors.length)){
          res.javascript = resStr;
        };
        p.resolve(res);

        return p.promise;
      }
    };
    
    
    
    return parser;
    


